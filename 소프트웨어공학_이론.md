# 2. 소프트웨어 개발 프로세스

## 소프트웨어 개발 단계

- 요구사항 - 설계- 구현- 테스트

# 3. 유지보수

- 유지보수

  - corrective : 수정 - 오류 발견 -> 수정

  - adaptive : 적응 - 운영체제/인프라 등 환경변화 -> 변화를 수용하도록 수정

  - perfective : 완전 - 기능이나 성능 개선 / 새로운 기능 추가 -> 수정/ 삭제 

  - preventive : 예방 - 소프트웨어의 오류 발생 전에 수정 -> **latent error** (ex 주석 작성)

    

- 유지 보수 비율 순서
  - perfective -> adaptive -> corrective -> preventive



# SDLC Model

- 폭포수 모델
- RAD
- 린 스타트 업
- 애자일 프로세스
- DevOps



# 4. 폭포수 모델

- 요구사항 -> 설계 -> 구현 -> 테스트 -> 유지보수
- 선형적 (linear)
- 순차적/계획 주도적 (sequential/plan-driven)
- **문제가 잘 정의, 예측 가능, 큰 변화 없는 시스템 개발에 적용**
- 단계별 산출물이 명확
- **요구사항 단계에서 모든 요구사항 식별해야함**

### 1 : 10 : 100 규칙

- 개발단계 - 제조 단계 - 서비스 단계
- 요구분석 -> 설계 -> 코딩 -> 단위 테스트 -> QA 테스트 -> 유지보수 순으로 비용이 많이 듬



# 5. iron triangle 과 폭포수

- scope, resourses, schedule
- scope는 고정



# 6. RAD

- 사용자의 지속적 참여하에 빠르게 애플리케이션을 개발하기 위한 개발 라이프 사이클 모델
- 자동 생성 도구 사용
- 사용자의 지속적인 참여, 지속적인 피드백 제공, 소프트웨어 지속적 개선
- 설계단계?에서 프로토 타입 Demonstrate(시제품 제작) - refine(피드백 반영) - develop(실제 개발) 를 반복
- 개발 속도가 가장 중요한 듯

### - 특성

- 고객 참여 : 요구사항 정의 , 분석, 설계
- 신속 개발 : risk 적고, 신속한 개발이 필요할 때
- 짧은 주기 : 코드 재사용, 자동 생성 도구로 인해 짧음 (60~90일)



#### 폭포수 모델과의 비교

- 예산 고정 안되어있음 / 폭포수: 예상 고정
- end 유저 용으로 적합하지 않음 / 폭포수: 적합



# 7. lean-startup

- 고객이 원하지 않는 제품을 만드는 것이 스타트업의 가장 큰 위험
- 시장조사, 시장의 반응이 포인트?
- 아이디어 빠르게 제품화 한 후 고객의 피드백을 받아 지속적으로 제품 개선
- 아이디어를 완벽 하게 구현하지 않아도 됨 / 실제 동작 될 필요도 없이 ppt나 영상과 같은 MVP도 괜찮
- 아이디어를 제품화 시키는 과정에서 고객의 피드백을 받아 시장이 원하는 제품을 만들겠다는 것이 전략
- startup : 조직



#### 프로세스

##### **MVP** : **고객의 반응이나 피드백을 가능할 만큼의** 아이디어의 핵심을 구현하는 제품

- 아이디어 - 만들기(MVP) - 제품 - 측정 - 데이터 - 학습 을 반복하는 사이클

- 가설 실험/학습은 일회성아니고 지속적인 과정
- 학습한 내용을 바탕으로 완전히 새로운 제품으로 방향전환**(pivot)**도 가능



# 8. 애자일

#### 반복적 / 점진적 개발

#### 이터레이션 iteration

#### 한 iteration이 끝난 후 나온 결과물을 고객에게 피드백 받음

#### 러한 개발 과정에서 좋은 제품 개발 방법 학습

#### * 폭포수 모델과의 비교*



## 애자일 프로세스

- 여러가지 종류가 있는데 그 중 하나가 **scrum**
- 이터레이션 : 요구분석 - 설계 - 구현 - 테스트 반복
- 요구사항에 우선순위가 있고 우선순위에 따라 개발 진행

**반복적이고 점진적인 개발 방법** **(IID, Iterative and Incremental Development)**에 기반

##### IID

- 개발 주기를 여러개의 iteration 주기로 구분

- 이터레이션 : 요구분석 - 설계 - 구현 - 테스트 반복

- 반복 주기 종료되면 부분적 완성 시스템 산출

- 반복주기에서 산출된 시스템은 내부 개발자가 관리 / 사용자에게 외부적으로 릴리즈 된는 것 -> 최종 반복주기의 산출물

- 각 반복 주기는 1주에서 4주

- 반복마다 새로운 요구사항 추가

- 요구사항은 고갱이 반복주기 전에 선택

- 요구사항에 우선순위를 준다

- 요구사항 선정이 반복주기 실행할 때마다 이루어져 자주 변경되는 고객의 요구사항 탄력적 처리 기회 제

- **반복 주기에 들어가 개발시작되면 요구사항 변경 안됨**

  

## 애자일 선언과 애자일 원칙 (한번 더 보기)

- 애자일 선언 : -**폭포수 모형과 같이 문서중심의 매우 복잡하고 프로세스 위주의 방법론과는 대치되는 개념** 
- 애자일 원칙 : PPT 확인
- 애자일 원칙 포인트
  - 작동하는 소프트웨어가 진척의 주된 척도이다.
  - 최고의 아키텍처, 요구사항, 설계는 자기 조직적인 팀에서 창발한다.
  - 비록 개발의 후반부일지라도 요구사항 변경을 환영하라. 



# 9. DevOps

- 개발 팀과 운용 팀이 긴밀히 협업하고 연계하여 비지니스 요구에 **신속**하게 대응하여 소프트웨어 개발 및 배포
  - "Development and operations teams collaborate closely and work together to **quickly** respond to business demands for software development and deployment."
- 배포된 소프트웨어가 운영환경에서 **안정적**으로 동작하도록 하여 비지니스 가치를 실현
  - "Ensure **stable** operation of the deployed software in the operational environment to realize business value."
- 개발과 운영에 대립문제 발생 => **Wall of Conflicts !!!**



## DevOps 프로세스

![image-20230417015300820](C:\Users\정유정\AppData\Roaming\Typora\typora-user-images\image-20230417015300820.png)

=> infinite loop



- plan : 요구사항

- code : 코드 구현 / 구현 코드 커밋

- build : 커밋된 코드 문제 없는지 검사 후 기존 코드와 통합

- test : 운영환경에 배포할 상태인지 테스트

- release : 최종 산출물 관리

- deploy : 최종 산출물을 실제 운영환경에 배포

- operate/monitor : 데이터 수집/분석하여 결과 통지하고 다음 개발 계획을 위해 피드백

  

## CD / CI

- CI : 지속적 통합
- CD : 지속적 전달



#### Big Bang Integration

- 코드의 통합이 프로젝트 종료 시점에 이루어짐
- intergration Hell
  - 뒤늦은 결함 발견
  - 오류 원인 파악 어려움
  - 배포 가능한 소프트웨어 부재
  - 제품에 대한 자신감 결여

#### CI - Continuous integration

- 여러 개발자가 공동 작업 하는 경우
- 각 개발자의 작업
- 초기부터 빈번하게 검증 및 통합이 이루어지도록 하는 방법 
- 빈번하게라면?? -> 매일 최소한 한 번 (오픈소스에서 했던그거)



- integration hell 없어짐

- 왜냐하면 빈번하게 통합하면

- 결함을 조기 발견할 수 있어 비용감소

- 위험(리스크가 감소)

- 품질에 대한 자신감이 생김

  **CI의 모든 과정이 적절한 tool chain을 통해 자동화**

